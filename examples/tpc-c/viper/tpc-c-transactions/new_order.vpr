import "../tpc-c-header.vpr"
// method testMaxOrderNum(o1: Order, o2: Order, id: Id){
//     assume get_o_num(o1) == 1
//     assume get_o_num(o2) == 2
//     assume get_o_d_id(o1) == id 
//     assume get_o_d_id(o2) == id
//     assert maxOrderNum(Set(o1,o2), id) == 2
// }

method testFilterNewOrdersByDistrict(n1: NewOrder, n2: NewOrder, n3: NewOrder){
    var d_id: Id
    assume n1 != n2
    assume get_no_d_id(n1) == d_id
    assume get_no_d_id(n2) == d_id
    assume get_no_d_id(n3) != d_id

    assume get_no_o_num(n1) == 1
    assume get_no_o_num(n2) == 2
    assume get_no_o_num(n3) == 3

    assert minNOrderNum(Set(n1,n2,n3), d_id) == 1
    assert maxNOrderNum(Set(n1,n2,n3), d_id) == 2

    assert filterNewOrdersByDistrict(Set(n1,n2,n3), d_id) == Set(n1,n2)
    assert |filterNewOrdersByDistrict(Set(n1,n2,n3), d_id)| == 2
}

method newOrder(
    g: Ref,
    // transaction parameters:
    w_id: Id,
    d_id: Id,
    c_id: Id,
    o_entry_d: Timestamp,
    i_ids: Seq[Option[Id]],
    i_w_ids: Seq[Id],
    i_qtys: Seq[Int]
) returns (
) 
requires readAll(g)
requires acc(g._orders, 1/2) && acc(g._orderLines, 1/2) && acc(g._newOrders, 1/2) && acc(g._districts, 1/2)
requires forall d1: District, d2: District :: // district ids are unique
    contains(g._districts, d1) && contains(g._districts, d2) && get_d_id(d1) == get_d_id(d2) ==> d1 == d2
requires forall o1: Order, o2: Order :: // order ids are unique
    contains(g._orders, o1) && contains(g._orders, o2) && get_o_num(o1) == get_o_num(o2) ==> o1 == o2
requires forall n1: NewOrder, n2: NewOrder :: contains(g._newOrders, n1) && contains (g._newOrders, n2) && // new Order order nums are unique
    get_no_o_num(n1) == get_no_o_num(n2) ==> n1 == n2
requires cc3(g)
requires cc5(g)
requires cc7(g)
// consistency criterion 1: year to date per warehouse is always equal to the sum of the year to dates of all related districts
requires forall w: Warehouse:: 
    contains(g._warehouses, w) ==> (
        get_w_ytd(w) == sumOfYtds(getDistrictsByWID(toSet(g._districts),get_w_id(w)))
    ) 
// // second consistency criterion: next order number per district always represents the maximum of order numbers for this district + 1
requires forall d: District :: contains(g._districts,d) ==> (
    get_d_next_order_num(d) - 1 == maxOrderNum(toSet(g._orders), get_d_id(d)) &&
    get_d_next_order_num(d) - 1 == maxNOrderNum(toSet(g._newOrders), get_d_id(d))
)
// // third criterion: the ids of new orders per district are continuous.
// requires forall d: District :: contains(districts, d) ==> (
//     maxNOrderNum(toSet(newOrders), get_d_id(d)) - minNOrderNum(toSet(newOrders), get_d_id(d)) + 1 ==
//     countNewOrders(toSet(newOrders), get_d_id(d))
// )
ensures readAll(g)
ensures forall d1: District, d2: District :: // district ids remain unique
    contains(g._districts, d1) && contains(g._districts, d2) && get_d_id(d1) == get_d_id(d2) ==> d1 == d2
// first criterion
ensures forall w: Warehouse ::
    contains(g._warehouses, w) ==> (
        get_w_ytd(w) == sumOfYtds(getDistrictsByWID(toSet(g._districts),get_w_id(w)))
    )
// second criterion
ensures forall d: District :: contains(g._districts,d) ==> (
    get_d_next_order_num(d) - 1 == maxOrderNum(toSet(g._orders), get_d_id(d)) &&
    get_d_next_order_num(d) - 1 == maxNOrderNum(toSet(g._newOrders), get_d_id(d))
)
// third criterion
// ensures forall d: District :: contains(districts_, d) ==> (
//     maxNOrderNum(toSet(newOrders_), get_d_id(d)) - minNOrderNum(toSet(newOrders_), get_d_id(d)) + 1 ==
//     countNewOrders(toSet(newOrders_), get_d_id(d))
// )
ensures cc3(g)
ensures cc5(g)
ensures cc7(g)
{
    var district: District := getDistrict(g._districts, d_id)
    var warehouse: Warehouse := getWarehouse(g._warehouses, w_id)
    var customer: Customer := getCustomer(g._customers, c_id)
    var nextOrderNum: Int := get_d_next_order_num(district)

    var allLocal: Bool := true
    var rollback: Bool := false

    var newOrderLines: Seq[OrderLine]
    newOrderLines := processOrderLines(nextOrderNum)

    assert forall d: District :: contains(g._districts, d) ==>
        maxNOrderNum(toSet(g._newOrders), get_d_id(d)) - minNOrderNum(toSet(g._newOrders), get_d_id(d)) + 1 ==
        countNewOrders(toSet(g._newOrders), get_d_id(d))

    if (!rollback){
        // gen order
        var order_: Order
        assume get_o_num(order_) == nextOrderNum
        assume get_o_d_id(order_) == d_id
        assume get_o_c_id(order_) == 0
        // find new id and add order
        var id: Int
        assume !(exists el: Order :: (id in (get_observed_ids(g._orders, el)) || id in (get_removed_ids(g._orders, el))))
        g._orders := add(g._orders, order_, id)
        assert toSet(g._orders) == toSet(old(g._orders)) union Set(order_)
        

        // add orderlines
        addOrderLines(g,newOrderLines)
        assert forall ol: OrderLine :: ol in newOrderLines ==> get_ol_del_date(ol) == 0
        assert get_o_c_id(order_) == 0
        assume forall ol: OrderLine :: ol in newOrderLines ==> !(exists o: Order :: contains(g._orders, o) && get_o_num(o) == get_ol_o_num(ol))
        assume forall ol: OrderLine :: ol in toSet(old(g._orderLines)) ==> get_ol_o_num(ol) != get_o_num(order_)
        assert toSet(g._orderLines) == toSet(old(g._orderLines)) union seqToSet(newOrderLines)
        assume forall ol: OrderLine :: contains(g._orderLines, ol) && get_ol_o_num(ol) == get_o_num(order_) ==> ol in newOrderLines && !(ol in toSet(old(g._orderLines)))
        assert forall ol: OrderLine :: contains(g._orderLines, ol) && get_ol_o_num(ol) == get_o_num(order_) ==>
            get_ol_del_date(ol) == 0 <==> get_o_c_id(order_) == 0
        assert forall o: Order :: contains(g._orders, o) && contains(old(g._orders), o) ==> get_o_c_id(o) == old(get_o_c_id(o))

        assert forall ol: OrderLine, o: Order :: contains(old(g._orders), o) && contains(old(g._orderLines), ol) && get_ol_o_num(ol) == get_o_num(o) ==> (
            get_ol_del_date(ol) == 0 <==> get_o_c_id(o) == 0)
        assert forall ol: OrderLine, o: Order :: ol in (toSet(g._orderLines) setminus seqToSet(newOrderLines)) && contains(old(g._orders), o) && get_ol_o_num(ol) == get_o_num(o) && o != order_ ==>
            (get_ol_del_date(ol) == 0 <==> get_o_c_id(o) == 0)
        
        // gen newOrder
        var neworder : NewOrder
        assume get_no_o_num(neworder) == get_o_num(order_)
        assume get_no_d_id(neworder) == d_id 
        // find new id and add newOrder
        var id2: Int
        assume !(exists el: NewOrder :: (id2 in (get_observed_ids(g._newOrders, el)) || id2 in (get_removed_ids(g._newOrders, el))))
        assume forall o: Order :: contains(old(g._orders), o) ==> get_o_num(o) != get_no_o_num(neworder)
        g._newOrders := add(g._newOrders, neworder, id2)

        assert get_o_c_id(order_) == 0 <==> is_new_order(toSet(g._newOrders), order_)
        assert contains(g._newOrders, neworder)
        assert forall n: NewOrder :: contains(old(g._newOrders), n) ==> contains(g._newOrders, n)
        // assume !contains(old(g._newOrders), neworder)
        assert toSet(g._newOrders) == toSet(old(g._newOrders)) union Set(neworder)
        assert get_no_d_id(neworder) == d_id
        assert neworder in filterNewOrdersByDistrict(toSet(g._newOrders), d_id)
        assert !(neworder in filterNewOrdersByDistrict(toSet(old(g._newOrders)), d_id))
        assert filterNewOrdersByDistrict(toSet(g._newOrders), d_id) == filterNewOrdersByDistrict(toSet(old(g._newOrders)),d_id) union Set(neworder)
        assert |filterNewOrdersByDistrict(toSet(g._newOrders), d_id)| == |filterNewOrdersByDistrict(toSet(old(g._newOrders)), d_id)| + 1
        assert get_no_o_num(neworder) == nextOrderNum
        assert forall no: NewOrder :: no in filterNewOrdersByDistrict(toSet(old(g._newOrders)), d_id) ==> nextOrderNum > get_no_o_num(no)
        assert minNOrderNum(toSet(g._newOrders), d_id) == minNOrderNum(toSet(old(g._newOrders)), d_id)
        assert countNewOrders(toSet(g._newOrders), d_id) == countNewOrders(toSet(old(g._newOrders)), d_id) + 1


        assert is_new_order(toSet(g._newOrders), order_)
        assert get_o_c_id(order_) == 0 <==> is_new_order(toSet(g._newOrders), order_)
        assert forall o: Order :: contains(old(g._orders), o) ==> contains((g._orders), o)
        assert forall o: Order :: old(contains(g._orders, o)) ==>
            (get_o_c_id(o) == 0 <==> is_new_order(toSet(old(g._newOrders)),o))
        assert forall o: Order :: contains(g._orders, o) && contains(old(g._orders),o) ==>
            (get_o_c_id(o) == old(get_o_c_id(o)))
        assert forall o: Order :: contains(g._orders, o) && contains(old(g._orders),o) ==>
            (is_new_order(toSet(g._newOrders), o) == old(is_new_order(toSet(g._newOrders), o)))
        assert forall o: Order :: o != order_ && contains(g._orders, o) ==>
            (get_o_c_id(o) == 0 <==> is_new_order(toSet(g._newOrders),o))

        g._districts := remove(g._districts, district) 
        // gen new district
        var district_: District := new_district(
            get_d_id(district),
            get_d_w_id(district),
            get_d_next_order_num(district) + 1,
            get_d_tax_rate(district),
            get_d_ytd(district)
        )
        // find new id and add modified district
        var id3: Int
        assume !(exists el: District :: (id3 in (get_observed_ids(g._districts, el)) || id3 in (get_removed_ids(g._districts, el))))
        g._districts := add(g._districts, district_, id3)

        // Helper Assertions
        assert toSet(g._districts) == old(toSet(g._districts)) setminus Set(district) union Set(district_)
        assert toSet(g._newOrders) == old(toSet(g._newOrders)) union Set(neworder)
        assert filterNewOrdersByDistrict(toSet(g._newOrders), d_id) == old(filterNewOrdersByDistrict(toSet(g._newOrders), d_id)) union Set(neworder)
        assert countNewOrders(toSet(g._newOrders), d_id) == old(countNewOrders(toSet(g._newOrders), d_id)) + 1
        assert minNOrderNum(toSet(g._newOrders), d_id) == minNOrderNum(toSet(old(g._newOrders)), d_id)
        assert maxNOrderNum(toSet(g._newOrders), d_id) == old(maxNOrderNum(toSet(g._newOrders), d_id)) + 1
        assert forall s1: Set[NewOrder], s2: Set[NewOrder], d: Id :: filterNewOrdersByDistrict(s1, d) == filterNewOrdersByDistrict(s2, d) ==> countNewOrders(s1,d) == countNewOrders(s2,d)
    }
    // save to assume since we don't update any ytds
    assume forall id: Id :: sumOfYtds(getDistrictsByWID(toSet(g._districts),id)) == sumOfYtds(getDistrictsByWID(old(toSet(g._districts)),id))
}

method processOrderLines(o_id: Int)
returns (newOrderLines: Seq[OrderLine])
ensures forall ol: OrderLine :: ol in newOrderLines ==> get_ol_del_date(ol) == 0 && get_ol_o_num(ol) == o_id

method addOrderLines(g: Ref, newOrderLines: Seq[OrderLine])
requires acc(g._orderLines)
ensures acc(g._orderLines, 1/2)
ensures toSet(g._orderLines) == old(toSet(g._orderLines)) union seqToSet(newOrderLines)