import "../../lib/crdts/aw_set.vpr"
import "types.vpr"
import "../../lib/basic_types.vpr"
import "helper_functions.vpr"

// GRAPH //
// sources
field _warehouses: AWSet[Warehouse]
field _districts: AWSet[District]
field _customers: AWSet[Customer]
field _orders: AWSet[Order]
field _newOrders: AWSet[NewOrder]
field _orderLines: AWSet[OrderLine]
field _items: AWSet[Item]
field _stocks: AWSet[Stock]
field _histories: AWSet[History]

// derived
// TODO
define readAll(g) acc(g._warehouses, 1/2) &&
    acc(g._districts, 1/2) && acc(g._customers, 1/2) &&
    acc(g._orders, 1/2) && acc(g._newOrders, 1/2) &&
    acc(g._orderLines, 1/2) && acc(g._items, 1/2) &&
    acc(g._stocks, 1/2) && acc(g._histories, 1/2)


// INVARIANTS
// third criterion: the ids of new orders per district are continuous.
define cc3(g) forall d: District :: contains(g._districts, d) ==> (
    maxNOrderNum(toSet(g._newOrders), get_d_id(d)) - minNOrderNum(toSet(g._newOrders), get_d_id(d)) + 1 ==
    countNewOrders(toSet(g._newOrders), get_d_id(d))
)

define cc5(g) forall o: Order :: contains(g._orders, o) ==> (
    get_o_c_id(o) == 0 <==> is_new_order(toSet(g._newOrders), o)
)

define cc7(g) forall ol: OrderLine, o: Order ::
    contains(g._orders, o) && contains(g._orderLines, ol) && get_ol_o_num(ol) == get_o_num(o) ==> (
    get_ol_del_date(ol) == 0 <==> get_o_c_id(o) == 0
) 

method test(a: Bool, b: Bool, c: Bool, d: Bool)returns(){
   assert (a ==> b <==> c ==> d) <==> ((a ==> b) <==> (c ==> d))
}