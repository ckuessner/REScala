// source reactives
val warehouses: Reactive[AWSet[Warehouse]] = Source(AWSet())
val paymentHistory: Reactive[AWSet[Payment]] = Source(AWSet())
val customers: Reactive[AWSet[Customer]] = Source(AWSet())
val districts: Reactive[AWSet[District]] = Source(AWSet())
val orders: Reactive[AWSet[Order]] = Source(AWSet())
val orderLines: Reactive[AWSet[OrderLine]] = Source(AWSet())
val newOrders: Reactive[AWSet[NewOrder]] = Source(AWSet())
val stocks: Reactive[AWSet[Stocks]] = Source(AWSet())
val items: Reactive[AWSet[Item]] = Source(AWSet())

// derived reactives
val DistrictYTD: Derived[Map[District, Int]] = Derived {
    // districts.map(d => 
    //     // get history entries per district
    //     val entries = History.filter(h => h.district == d)
    //     // calculate sum of all amounts
    //     val ytd = entries.map(_.amount).sum()
    //     (d,ytd)
    // ).toMap()
    districts + paymentHistory + TODO
}

val WarehouseYTD: Derived[Map[Warehouse, Int]] = Derived {
    // warehouses.map(w =>
    //     // get districts per warehouse
    //     val districts = districts.filter(_.warehouse == w) 
    //     // sum YTD values
    //     val ytd = districts.map(districtYTD(_)).sum()
    //     (w,ytd)
    // ).toMap()
    warehouses + districts + districtYTD + TODO
}

val CustomerYTD: Derived[Map[Customer, Int]] = Derived {
    // customers.map(c =>
    //     // get sum of all payments
    //     val payments = history.filter(_.customer = c).map(_.amount).sum
    //     (c, payments)
    // ).toMap()
    customers + paymentHistory + TODO
}

val customerBalance: Reactive[Map[Customer, Int]] = Derived {
    // customers.map(c =>
    //     // get sum of all orders
    //     val olAmounts = orderLines.filter(_.customer = c).map(_.amount).sum
    //     // get payment sum from reactive
    //     val payments = customerYTD(c)
    //     (c, olAmounts -  payments)
    // ).toMap()
    customers + orderLines + customerYTD + TODO
}

val nextOrderId: Derived[Map[District, Int]] = Derived {
    // districts.map(d =>
    //     val nextId = orders.filter(_.district == d).length() + 1
    //     (d,nextId)
    // ).toMap()
    districts + orders + TODO
}

val orderLnCnt: Derived[Map[Order, Int]] = Derived {
    // orders.map(o => 
    //     val cnt = orderLines.filter(_.order == o).length()
    //     (o, cnt)
    // ).toMap()
    orders + orderLines + TODO
}

// invariants
// CC3: The maximum new order ID - the minimum new order ID + 1 is equal to the number of new orders for each district.
@invariant forall d: District :: d in Districts ==>
    size(getNewOrdersPerDistrict(d)) ==
        getNewOrdersPerDistrict(d).map(_.id).max() -
        getNewOrdersPerDistrict(d).map(_.id).min() + 1

def payment(w_id: Id, d_id: Id, h_amount: Float, c_w_id: Id, c_d_id: Id, c_id: Option[Id],
    c_last: Option[String], h_date: Timestamp) = {
        val customer: Customer = getCustomer()
        val payment: Payment = makePayment()

        paymentHistory.transform(_.add(payment))
    }