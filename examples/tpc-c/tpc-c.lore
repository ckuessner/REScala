//> viperimport viper/tpc-c-header-new.vpr

// graph definition
val warehouses: Source[AWSet[Warehouse]]  = Source(AWSet()) 
val districts: Source[AWSet[District]]    = Source(AWSet()) 
val customers: Source[AWSet[Customer]]    = Source(AWSet())
val orders: Source[AWSet[Order]]          = Source(AWSet())
val newOrders: Source[AWSet[NewOrder]]    = Source(AWSet())
val orderLines: Source[AWSet[OrderLine]]  = Source(AWSet())
val items: Source[AWSet[Item]]            = Source(AWSet())
val stocks: Source[AWSet[Stock]]          = Source(AWSet())
val paymentHistory: Source[AWSet[History]]     = Source(AWSet())


// fixme: before compiling to Viper, check which derived reactives are used in interactions and invariants
// val warehouseYTD: Derived[Map[Warehouse, YTD]] = Derived {
// 	districtsPerWarehouse(warehouses,districts)
// 	.map(d => districtYTD.get(d)).toMap()
// }
val districtYTD: Derived[Map[District, YTD]] = Derived{
	paymentsPerDistrict(districts,paymentHistory).map(sum).toMap()
}
val customerYTD: Derived[Map[Customer, YTD]] = Derived{
	paymentsPerCustomer(customers, paymentHistory).map(sum).toMap()
}
// val customerBalance: Derived[Map[Customer, Balance]] = Derived {
// 	sumOfOrdersPerCustomer(customers, oderLines).map((c, s) => customerYTD.get(c) - s).toMap()
// }
// val nextOrderId: Derived[Map[District, OrderID]] = Derived{
// 	highestOrderIDperDistrict(districts, oders).map(id => id + 1).toMap()
// }
val orderLineCount: Derived[Map[Order, Int]] = Derived{
	orderLinesPerOrder(orders, orderLines).map(length).toMap()
}

// invariants
// cc3
invariant forall d: District :: districts.contains(d) ==> 
    (maxNOrderNum(toSet(newOrders), get_d_id(d)) - minNOrderNum(toSet(newOrders), get_d_id(d)) + 1 ==
    countNewOrders(toSet(newOrders), get_d_id(d)))
// cc4
invariant forall o: Order :: orders.contains(o) ==> 
    (get_o_c_id(o) == 0 <==> is_new_order(toSet(newOrders), o))
// cc7
invariant forall ol: OrderLine, o: Order ::
    orders.contains(o) && orderLines.contains(ol) && get_ol_o_num(ol) == get_o_num(o) ==> (
    get_ol_del_date(ol) == 0 <==> get_o_c_id(o) == 0
) 

type PaymentArgs = (Id, String, Int)
// TODO: payment
val payment: Unit = Interaction[AWSet[History]][PaymentArgs]

type NOArgs = (Id, Id, Id, Timestamp, Seq[Option[Id]], Seq[Id], Seq[Int])
val new_order: Unit = Interaction[(AWSet[District], AWSet[NewOrder], AWSet[Order], AWSet[OrderLine])][NOArgs]
    .modifies(districts, newOrders, orders, orderLines)
	// helper assertions
	.requires{forall w: Warehouse ::
		contains(warehouses, w) ==> (
			get_w_ytd(w) == sumOfYtds(getDistrictsByWID(toSet(districts),get_w_id(w)))
	)}
	.requires{forall d: District :: contains(districts,d) ==> (
		get_d_next_order_num(d) - 1 == maxOrderNum(toSet(orders), get_d_id(d)) &&
		get_d_next_order_num(d) - 1 == maxNOrderNum(toSet(newOrders), get_d_id(d))
	)}
	 // district ids are unique
	.requires{forall d1: District, d2: District ::
		contains(districts, d1) && contains(districts, d2) && get_d_id(d1) == get_d_id(d2) ==> d1 == d2}
	// order ids are unique
	.requires{forall o1: Order, o2: Order :: 
	    contains(orders, o1) && contains(orders, o2) && get_o_num(o1) == get_o_num(o2) ==> o1 == o2}
	// new Order order nums are unique
	.requires{forall n1: NewOrder, n2: NewOrder :: contains(newOrders, n1) && contains(newOrders, n2) && 
    	get_no_o_num(n1) == get_no_o_num(n2) ==> n1 == n2}
	 // district remain unique
	.ensures{forall d1: District, d2: District ::
		contains(districts, d1) && contains(districts, d2) && get_d_id(d1) == get_d_id(d2) ==> d1 == d2}
	// helper assertions
	.ensures{forall w: Warehouse ::
		contains(warehouses, w) ==> (
			get_w_ytd(w) == sumOfYtds(getDistrictsByWID(toSet(districts),get_w_id(w)))
	)}
	.ensures{forall d: District :: contains(districts,d) ==> (
		get_d_next_order_num(d) - 1 == maxOrderNum(toSet(orders), get_d_id(d)) &&
		get_d_next_order_num(d) - 1 == maxNOrderNum(toSet(newOrders), get_d_id(d))
	)}
	.executes{
		(districts, newOrders, orders, orderLines) =>
			(w_id, d_id, c_id, o_entry_d, i_ids, i_w_ids, i_qtys) => {
				val district: District = getDistrict(districts, d_id)
				val warehouse: Warehouse = getWarehouse(warehouses, w_id)
				val customer: Customer = getCustomer(customers, c_id)
				val nextOrderNum: Int = get_d_next_order_num(district)

				val newOrderLines: Seq[OrderLine] = processOrderLines(nextOrderNum)
				(0,0,0,0)	
			}
	}

val delivery: Unit = Interaction[(AWSet[NewOrder], AWSet[Order], AWSet[OrderLine])][Id]
	.modifies(newOrders, orders, orderLines)
	.executes{
		(no, o, ol) => w_id => {
			// get districts of this warehouse
			val whDistricts: Set[District] = getDistrictsByWID(toSet(districts), w_id)
			(
				// ship newest order per district
				shipNewOrders(whDistricts, o, no),

				// set carrier id in orders
				setCarrierIds(o, no),

				// set delivery dates
				setDeliveryDates(ol, o)
			)
		}
	}
