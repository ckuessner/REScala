//> viperimport viper/tpc-c-header-new.vpr

// graph definition
val warehouses: Source[AWSet[Warehouse]]  = Source(AWSet()) 
val districts: Source[AWSet[District]]    = Source(AWSet()) 
val customers: Source[AWSet[Customer]]    = Source(AWSet())
val orders: Source[AWSet[Order]]          = Source(AWSet())
val newOrders: Source[AWSet[NewOrder]]    = Source(AWSet())
val orderLines: Source[AWSet[OrderLine]]  = Source(AWSet())
val items: Source[AWSet[Item]]            = Source(AWSet())
val stocks: Source[AWSet[Stock]]          = Source(AWSet())
val paymentHistory: Source[AWSet[History]]     = Source(AWSet())

// cc3
invariant forall d: District :: districts.contains(d) ==> 
    (maxNOrderNum(toSet(newOrders), get_d_id(d)) - minNOrderNum(toSet(newOrders), get_d_id(d)) + 1 ==
    countNewOrders(toSet(newOrders), get_d_id(d)))
// cc4
invariant forall o: Order :: orders.contains(o) ==> 
    (get_o_c_id(o) == 0 <==> is_new_order(toSet(newOrders), o))
// cc7
invariant forall ol: OrderLine, o: Order ::
    orders.contains(o) && orderLines.contains(ol) && get_ol_o_num(ol) == get_o_num(o) ==> (
    get_ol_del_date(ol) == 0 <==> get_o_c_id(o) == 0
) 

// fixme: before compiling to Viper, check which derived reactives are used in interactions and invariants
// val warehouseYTD: Derived[Map[Warehouse, YTD]] = Derived {
// 	districtsPerWarehouse(warehouses,districts)
// 	.map(d => districtYTD.get(d)).toMap()
// }
val districtYTD: Derived[Map[District, YTD]] = Derived{
	paymentsPerDistrict(districts,paymentHistory).map(sum).toMap()
}
val customerYTD: Derived[Map[Customer, YTD]] = Derived{
	paymentsPerCustomer(customers, paymentHistory).map(sum).toMap()
}
// val customerBalance: Derived[Map[Customer, Balance]] = Derived {
// 	sumOfOrdersPerCustomer(customers, oderLines).map((c, s) => customerYTD.get(c) - s).toMap()
// }
// val nextOrderId: Derived[Map[District, OrderID]] = Derived{
// 	highestOrderIDperDistrict(districts, oders).map(id => id + 1).toMap()
// }
val orderLineCount: Derived[Map[Order, Int]] = Derived{
	orderLinesPerOrder(orders, orderLines).map(length).toMap()
}

val delivery: Unit = Interaction[(AWSet[NewOrder], AWSet[Order], AWSet[OrderLine])][Id]
	.modifies(newOrders, orders, orderLines)
	.executes{
		(no, o, ol) => w_id => {
			// get districts of this warehouse
			val whDistricts: Set[District] = getDistrictsByWID(toSet(districts), w_id)

			(
				// ship newest order per district
				shipNewOrders(whDistricts, o, no),

				// set carrier id in orders
				setCarrierIds(o, no),

				// set delivery dates
				setDeliveryDates(ol, o)
			)
		}
	}
